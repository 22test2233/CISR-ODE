# ODE-CISR
Customized ODE framework for engineers and scientists

## About

ODE-CISR is a C++ code framework to provide a flexible simulation environment for variety of models especially for control systems with block diagrams. This framework aims to provide comfortable facilities for engineers and scientists to ease the modelling programming of simple or complicated systems. This framework aims to be a good C++ alternative for MATLAB Simulink.

This framework allows user to define models, specify the input, output, states and connections. The framework generates partial of the code automatically for user convenience. Each time this program runs, all outputs are stored in a new file with the figure of requested parameters and output log(in HTML format) inside the output folder. This framework stores the output in a matrix labelled by time and `dt` and it generates an `SHA1` signature for each output to identify it. This helps engineers to detect if two outputs are identical. 

This framework solver is based on ODE (Ordinary Differential Equation) solver with variable step sizes using Runge Kutta methods Dormand-Prince (RKDP5), Cash-Karp (RKCK45) (and in near future Fehlberg RKF78).

This solver uses Armadillo matrix library for the vectors. This library is fast and easy to use. The syntax of this library is more closed to MATLAB syntax compared to the other C++ libraries and easier for engineers. 

## Requirements

To use this software, you need to have a Unix based operating system with installation of a few applications and libraries:  
* GCC compiler
* Armadillo matrix library ([link](http://arma.sourceforge.net/))

## Solver

The solver of this framework is based on a code obtained from works of [Boost ODEINT](http://odeint.com). In this framework, this code has been dramatically changed to fit into the new structure and follow several goals. The heavy usage of templates were used in ODEINT to fit it with a very wide range of matrix/vector classes and libraries. This design is very complicated, hard to trace, very slow on compiling time and boring during long period of development (however fast while running), making the name of each type very lengthy and over multiple lines, generating very confusing error messages on compiler errors and very uncomfortable for engineers during developments.


The following changes have been done to the original code:

* The solver has been specialized for Armadillo matrices/vectors and the usage of templates have been minimized dramatically.
* the compilation time has been decreased (due to template specialization).
* The number of library files has been decreased from over 160 to a few files (currently 4 files).
* All SFINAE s have been removed and the code is easier to understand.
* The ODEINT solver does not support maximum step size while many engineers expect this facility for their works, thesis, etc. In this framework, the maximum step size is introduced.
* The original solver does not support specified times to stop which is necessary for implementation of many engineering applications such as Model Predictive Control (MPC). This project supports this demand.
* The original code does not consider sudden changes in the input which may occur frequently in many industries. The step size may become large enough to escape some inputs `u(t)`. In this project the function generating the input signal can inform the solver about the next occurrence of sudden change in the input.
* Observer, right hand side (RHS) and precisions are placed in a single class for easier usage and avoid passing them separately at each solving process.

## The structure of this framework
This framework includes the following files and directories:

* `./app_models/`: Containing the models (each model in a new directory).
* `./application/`: Including the main file and other required application codes for forming this structure. The file `system.hpp` can be manipulated to meet the user demands.
* `./libs/`: It is a directory including libraries handling log, profiling, SHA1 signature, SVG graphic file generation, transfer function to state space matrix converter, etc.
* `./resource/`: Including HTML templates and partial codes used in automatic output generation.
* `./scripts/`: Containing Linux bash scripts to generate automatic codes and do repetitive jobs for user.
* `./unit_test/`: Containing tests to examine the libraries according to the demands.
* `./Makefile`: For compiling, build and running 
* `./models`: Selecting the active models

There are two other directories which are generated automatically:
* `./bin/`: This directory is generated by Makefile and contains the executive program. 
* `./out/`: This directory is generated by the executive file and the results, output figures and log files are stored in this folder.


## How to use this framework to simulate your model?

To use this framework, the users need to have the block diagram of their model. In this section the steps of using this framework is explained step by step.

Consider the example of _classical washout filter_ :

![The plain diagram of classical washout filter](https://cloud.githubusercontent.com/assets/11730626/6981680/ac9d2f42-da51-11e4-9d46-267778756379.png)

First of all, you must determine the outputs of this system:

![The classical washout filter with labelled outputs](https://cloud.githubusercontent.com/assets/11730626/6981769/f3138bf0-da52-11e4-8276-b3705e2ed364.png)

Blocks with memories must be identified and marked with their states. The states start from number zero (`x0`) however the order of marking members of `dx/dt` is not important:

![The classical washout filter with labelled states](https://cloud.githubusercontent.com/assets/11730626/6981900/7d47bdda-da55-11e4-965f-2252f86e5e04.png)

The connections between blocks (intermediates) must be marked up starting from zero (`m0`). Each intermediate must only depend on the previous one. For example, `m9` can depend on `m6` and `m8`. But calculation of `m9` should not depend on `m10`. If this sequence is not regarded, each intermediate might use another one before its calculation. The following code is expected to give wrong results:

    m0=m1+m2
    m1=...
    m2=...

 In cases where regarding this rule is not possible such as systems with feedback, it is duty of programmer to avoid algebraic loops and deciding how intermediates should be marked up. They must look for components with memories which do not have instantaneous relationship between their input and output.

![The classical washout filter with labelled intermediates](https://cloud.githubusercontent.com/assets/11730626/6981946/5177528c-da56-11e4-983b-87df20bac5c4.png)

In the next step, from folder `./app_models` copy paste `empty_model` with a desired new name. Change the name of active model in file `./models` and avoid any extra new line or token in this file.

**Note:** Running make on this application with new empty model must work with no error or warning.

From here, `./app_models/<your_model_name>` is referred by shorter phrase `<model>`.

In the next step, from `<model>/vectors`, fill up all `*.list` files and at each line write down the name of the vector item. In `inputs.list`, write down the list of inputs from the diagram:

    surge_acc
    pitch_angle

In `states.list`, write down the list of states from the diagram:

    surge_hp_x1
    surge_hp_x2
    surge_kin_vel
    surge_kin_pos
    surge_lp_x1
    surge_lp_x2
    pitch_hp_x1

In `intermediates.list`, write down the list of intermediates according to the diagram:

    surge_input_acc_ref
    surge_hp_out
    surge_kin_acc
    surge_kin_vel
    surge_kin_pos
    surge_lp_out
    tilt_coordination
    pitch_input_angle_ref
    pitch_hp_out
    pitch_angle
    tilt_force
    specific_force

In `outputs.list`, write down the list of intermediates which are supposed to be stored. If the figure of that intermediate respect to time is required, it must be followed by a comma and then word `plot`:

    surge_input_acc_ref,plot
    surge_hp_out
    surge_kin_acc
    surge_kin_vel
    surge_kin_pos
    surge_lp_out
    specific_force,plot

If there is no comma after an intermediate or it is followed by any other word than `plot` (such as `none`), that output would not be plotted.

Then, you need to use some parts of the auto-generated codes according to your model. In the root directory of the framework, run makefile:

    make

It does the following actions:
* Including your new model (obtained from `./models`) by updating the related codes (`./application/autogenerated/embed_models.hpp`). 
* Updating list of your vectors (`<model>/autogenerated/model_*.hpp`)
* Providing you a template code for more comfortable vector assignment (`<model>/autogenerated/user_template.hpp`).

Then, go to the `<model>/autogenerated/user_template.hpp` and find sections related to inputs, states and intermediates.

Copy the generated codes of inputs section into `<model>/model.hpp` inside method `Model::input`. And edit this code according to your need for input signal:

    u(inputs::surge_acc)=(t>1.0&&t<5.0?1.0:0.0);
    u(inputs::pitch_vel)=0;

Copy the generated codes of intermediates section into `<model>/model_mids.hpp` inside method `Model::intermediates` and fill it according to the model diagram connections:

    // m0   surge_input_acc_ref
    // m1   surge_hp_out
    // m2   surge_kin_acc
    // m3   surge_kin_vel
    // m4   surge_kin_pos
    // m5   surge_lp_out
    // m6   tilt_coordination
    // m7   pitch_input_angle_ref
    // m8   pitch_hp_out
    // m9   pitch_angle
    // m10  tilt_force
    // m11  specific_force

    #define M(a) mid(mids::a)
    #define X(a) x(states::a)
    M(surge_input_acc_ref)=u(inputs::surge_acc);
    M(surge_hp_out)=hp_surge_out(mid,x);
    M(surge_kin_acc)=std::max(-max_acc,std::min(+max_acc,M(surge_hp_out)));
    M(surge_kin_vel)=X(surge_kin_vel);
    M(surge_kin_pos)=X(surge_kin_pos);
    M(surge_lp_out)=lp_surge_out(x);
    M(tilt_coordination)=M(surge_lp_out)/g;
    M(pitch_input_angle_ref)=u(inputs::pitch_vel);
    M(pitch_hp_out)=hp_pitch_out(mid,x);
    M(pitch_angle)=M(tilt_coordination)+M(pitch_hp_out);
    M(tilt_force)=M(pitch_angle)*g;
    M(specific_force)=M(tilt_force)+M(surge_kin_acc);   
    #undef M
    #undef X

Copy the generated codes of states section into `<model>/model_rhs.hpp` and fill it up according to the model:

    // x0   surge_hp_x1
    // x1   surge_hp_x2
    // x2   surge_kin_vel
    // x3   surge_kin_pos
    // x4   surge_lp_x1
    // x5   surge_lp_x2
    // x6   pitch_hp_x1

    // x_dot(states::surge_hp_x1)=...
    // x_dot(states::surge_hp_x2)=...
    hp_surge(mid,x,x_dot);

    x_dot(states::surge_kin_vel)=mid(mids::surge_kin_acc);

    x_dot(states::surge_kin_pos)=mid(mids::surge_kin_vel);

    // x_dot(states::surge_lp_x1)=...
    // x_dot(states::surge_lp_x2)=...
    lp_surge(mid,x,x_dot);

    // x_dot(states::pitch_hp_x1)=...
    hp_pitch(mid,x,x_dot);


Then, add the used functions in the `protected` part of `class Model`:
`hp_surge`, `hp_surge_out`, `lp_surge`, `lp_surge_out`, `hp_pitch`, `hp_pitch_out`

    static void hp_surge(const intermediate_type &mid,const state_type &x,state_type &x_dot)
    {
        ...
    }

    static double hp_surge_out(const intermediate_type &mid,const state_type &x)
    {
        return ...
    }

    static void lp_surge(const intermediate_type &mid,const state_type &x, state_type &x_dot)
    {
        ...
    }

    static double lp_surge_out(const state_type &x)
    {
        return ...
    }

    static void hp_pitch(const intermediate_type &mid,const state_type &x, state_type &x_dot)
    {
        ...
    }

    static double hp_pitch_out(const intermediate_type &mid,const state_type &x)
    {
        return ...
    }

**Warning:** You should not edit any file inside any `autogenerated` folder as they are update at each build.

It is strongly recommended that:

1. All intermediates are obtained from:
 * inputs
 * states
 * other connected intermediates

1. All states are obtained from:
 * intermediates which are the input to the block
 * states which are inside the same blocks.

1. Do not call any input two times. Instead, associate an intermediate(connection) between an input and its connected blocks. Sometimes, input generators can be time consuming.

If you do not use any variable, use

    _unused(varname);

to suppress compiler warnings.

Unlike the intermediates, the state derivatives can be assigned in any order.

To compile the code, call make at root of the framework:

    make

It generates an executive file inside `./bin/` directory. This code generation comes out with the following message:

    $ make
    ****************************************************************************************************
    ./application/autogenerated/embed_models.hpp updated
    ./app_models/classical_washoutfilter/autogenerated/model_outputs.hpp updated
    ./app_models/classical_washoutfilter/autogenerated/model_observer.hpp updated
    ./app_models/classical_washoutfilter/autogenerated/model_states.hpp updated
    ./app_models/classical_washoutfilter/autogenerated/model_intermediates.hpp updated
    ./app_models/classical_washoutfilter/autogenerated/model_inputs.hpp updated
    g++ -c -Wall -Wconversion -Wfatal-errors -Wextra -std=c++11 -MD -MP -g -MF ./bin/obj/application/main.d -o bin/obj/application/main.o  application/main.cpp
    g++  bin/obj/application/main.o -o bin/sim -lboost_filesystem -lboost_system -lcrypto -lrt
    done


To run the executive file

    make run

The command above runs the built executive file. The outputs results and figures are generated inside folder `./out/`:

    ./bin/sim
    Results(2015/04/03 12:28:01) SHA1: 4ed31929715e85076969cea400756a945825033e

The head of content of `./out/data_20150403_122801__results` is

    t   dt  surge_input_acc_ref surge_hp_out    surge_kin_acc   surge_kin_vel   surge_kin_pos   surge_lp_out    specific_force
    0   0.1 0   0   0   0   0   0   0
    0.1 0.45    0   0   0   0   0   0   0
    0.55    2.025   0   0   0   0   0   0   0
    0.955   1.8225  0   0   0   0   0   0   0
    0.96958 0.06561 0   0   0   0   0   0   0
    0.982702    0.059049    0   0   0   0   0   0   0
    0.994512    0.0531441   0   0   0   0   0   0   0
    0.996638    0.00956594  0   0   0   0   0   0   0
    0.998551    0.00860934  0   0   0   0   0   0   0
    ...

data_20150403_122801__results_surge_input_acc_ref.svg

![02](https://cloud.githubusercontent.com/assets/11730626/6984273/cf164f42-da72-11e4-8d2f-402e2e53ef91.png)

data_20150403_122801__results_specific_force.svg

![03](https://cloud.githubusercontent.com/assets/11730626/6984275/d66f2c64-da72-11e4-8788-43a4c4975eb9.png)


## Unit test
This application is not test driven. The purpose of using unit test is to check the validity of core codes such as comparing new ODE code with its original code.

## Facilities
Inside folder `./libs/` there are libraries for providing more facilities for the programmer. These facilities include:
* profiler
* SHA1 check sum for identifying the output
* SVG file generator
* Transfer function to state space matrices converter
* Log file generator

This library folder is planned to be extended depending on global user needs.

## Platform
This application is originally written for Linux environments. It has been tested on Ubuntu and works fine. We expect that this application works fine on other Unix based operating systems such as Mac. This application does not work on windows due to bash scripts used for automatic code generation. We plan to translate those scripts into another language such as Python to be run on all operating systems.

## Using simplified solver without the framework.
It is possible that one uses the simplified solver only. For this purpose, just use `./libs/solver/` folder and add it into your new project. You need to provide the required `typenames` which were used in this library.  

## Licence

This application free and open source and it is distributed under the Boost Software License. For more details see:

http://www.boost.org/LICENSE_1_0.txt

## Feedbacks and further updates
No software is fool-proof and this one is not an exception. I am very glad to respond user issues, their problems and suggestions as far as I am free.

In addition, providing a supportive documentation is one of the main goals of this project. In case of any ambiguity in the document or need for any further explanation please contact me.

If you are user of another Linux distribution and you have technical difficulty or you do not know how to install package requirements, please report it so we can provide more clear information about these problems to all users.  
